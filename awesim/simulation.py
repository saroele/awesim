# -*- coding: utf-8 -*-
"""
class Simulation:
-----------------
    Class for doing operations one 1 single simulation file
    The simualation files are supposed to be generated by Dymola, or at 
    least have the same structure.  
    A Simulation object contains all the (useful) info that is in the .mat file.
    Therefore, objects of the Simulation class are relatively memory intensive,
    depending on the size of the .mat file.
    
    Most important attributes are:
        - self.filename (path to the .mat file)
        - self.names (list of all variable and parameter names)
        - self.dataInfo (mapping of vars and pars to data1 and data2)
        - self.data1 (contains the values of the parameters)
        - self.data2 (contains the values of the variables (timeseries))
    
    Most important methods are:
        - get_value(name) : retreives the value(s) for name, name can be 
          a parameter or a variable
        - exist(regex) : returns all vars and pars that satisfy the regex

@author: Roel De Coninck
"""

import numpy as np
from scipy.integrate import cumtrapz
import os
import scipy.io
import re
import copy
#import matplotlib.pyplot as plt
#from matplotlib.dates import date2num
#import cPickle as pickle
#import bisect
#import tables as tbl
#from datetime import datetime, timedelta
import pandas
import pdb

class Simulation:
    """
    Class for doing operations one single simulation file
    The simulation files are supposed to be generated by Dymola, or at 
    least have the same structure.  
    A Simulation object contains all the (useful) info that is in the .mat file.  
    Therefore, objects of the Simulation class are relatively memory intensive,
    depending on the size of the .mat file.
    
    Most important attributes are:
        - self.filename (path to the .mat file)
        - self.names (list of all variable and parameter names)
        - self.dataInfo (mapping of vars and pars to data1 and data2)
        - self.data1 (contains the values of the parameters)
        - self.data2 (contains the values of the variables (timeseries))
    
    Most important methods are:
        - get_value(name) : retreives the value(s) for name, name can be 
          a parameter or a variable
        - exist(regex) : returns all vars and pars that satisfy the regex
    
    """
    
    def __init__(self, filename, verbose = False):
        ''' 
        Create a Simulation object from a .mat file
        The filename can be an absolute path, or a filename in the current work
        directory, but it must NOT have a .mat extension.
        '''
        
        self.verbose = verbose        
        # turn filename in an absolute path
        # no .mat extension needed, it is added by the scipy.io.loadmat method
        filename = os.path.abspath(filename)
        try:
            d = scipy.io.loadmat(filename, chars_as_strings = False)
            # if all goes well, d is a dictionary 
            
        except(UnicodeDecodeError):
            print 'This error is caused by non-ascii characters in the .mat file\
             like Â°C'
            print 'Modify the scipy.io.mio4.py file by adding ,"replace" in the\
             line that causes the error'
            raise
        
        # check the fields of d to make sure we're having a dymola file        
        try:
            for field in ['dataInfo', 'name', 'data_1', 'data_2'] :
                # here we create numpy arrays with names dataInfo, name, 
                # data_1 and data_2
                stringske = field + '=d[field].transpose()'
                exec(stringske)
        except :
            print '%s is no Dymola file.  No Simulation object created' % \
                (filename)
            raise IOError
                
        # Now we have dataInfo, data_1 and data_2 from the first Dymola file

        # data_1 contains the values of the parameters
        # data_2 contains the values of the variables (timeseries)
        # name contains parameter and variable names but it is 
        # still 'transposed'.  
        # dataInfo contains all metadata about parameters and variables 

        # For future reference, it's important to understand how the data 
        # is structured.  dataInfo has 4 columns and contains a row for
        # each row of names
        
        # Matrix with 4 columns defining the data of the signals:
        # dataInfo(i, 1)= j: name i data is stored in matrix "data_j".
        # dataInfo[0, 0] = 0, means that names[0] is used as abscissa
        # for ALL data matrices!  Normally, names[0]='Time'
        #
        # dataInfo(i, 2)= k: name i data is stored in column abs(k) of matrix
        # data_j with sign(k) used as sign.
        #
        # dataInfo(i, 3)= 0: Linear interpolation of the column data
        # = 1..4: Piecewise convex hermite spline interpolation
        # of the column data. Curve is differentiable upto
        # order 1..4. The spline is defined by a polygon.
        # It touches the polygon in the middle of every segment
        # and at the beginning and final point. Between such
        # points the spline is convex. The polygon is also the
        # convex envelope of the spline.
        #
        # dataInfo(i, 4)= -1: name i is not defined outside of the defined 
        # time range
        # = 0: Keep first/last value outside of time range
        # = 1: Linear interpolation through first/last two points outside
        # of time range.
        

        names = [] 
        # names will be list with names of all parameters and variables 
               
        for i in range(name.shape[0]):
            names.append(''.join(name[i, :]).strip())        
        
                
        self.names = names
        self.dataInfo = dataInfo
        self.data_1 = data_1
        self.data_2 = data_2
        self.filename = filename

    def __str__(self):
        print self.filename
        
        return self.filename
        
    def __len__(self):
        return len(self.simulations)


    def get_value(self, name):
        '''
        get_value(self, name)
    
        This function returns a numpy array with the value(s) of 'name' 
        '''
        
        result = []
        try:
            name_index = self.names.index(name)
        except (ValueError):
            print '%s not found in %s' % (name, self.filename)
            print 'Did you mean one of the following: '
            print self.exist(name)
            raise
            
        possign = self.dataInfo[name_index, 1]
        pos = abs(possign)
        #pos is the row number in data_1 or data_2
        sign = np.sign(possign)
        #sign indicates the sign of the values 
        if self.dataInfo[name_index, 0] == 1:
            source = 'self.data_1'
            # it is a parameter, found in data_1
            stringske = "result=" + source + "[:,pos-1][0]*sign"
        elif self.dataInfo[name_index, 0] == 2 or \
            self.dataInfo[name_index, 0] == 0:
            source = 'self.data_2'
            # important: by testing I found out that get_value for variables
            # gives the last value 2 times.  So I omit the last value here.
            stringske = "result=" + source + "[:-1, pos-1]*sign"
        else:
            raise ValueError('name not found')
        
        exec(stringske)
        return result
        
    def exist(self, regex): 
        """
        exist(regex) 
        
        regex = regular expression, not case sensitive
                
        This method searches for parameter and variable names matching the 
        regular expression in self.names.
        It returns a list with all matching names from self.names
        
        Attention: if you want to check if eg.  c[3].T exists, you have to 
        escape the [ and ] with a backlslash, like this:
        self.exist('c\[3\].T). Otherwise c3.T is sought for. This is 
        because in regex syntax, [] is used to indicate a set of characters.
                
        """
        
        p = re.compile(regex, re.IGNORECASE)
        matches = []
        for i in range(0, len(self.names)):
            m = p.search(self.names[i])
            if m:
                matches.append(self.names[i])
        
        return matches

    def separate(self):
        '''
        separate()
        
        Separates variables from parameters and adds 2 lists and 1 numpy array 
        as attributes:
            - list parameters (sorted)
            - list variables (sorted)
            - numpy array parametervalues 
        This method returns True if successfull
        '''
        # We create a loop over each of the elements in names, check if it is 
        # parameter or variable. We update the attributes parameters and 
        # variables, and if it is a parameter, we put the value in 
        # parametermap
    
        parameters = []
        variables = []
        parametervalues = []
        # parametervalues is a list with the values of the parametes for this
        # run.  Will be converted to array and become self.parametervalues
        
        for i in range(len(self.names)):
            par_or_var = self.names[i] #string with the name of the par or var
            
            possign = self.dataInfo[i, 1]
            pos = abs(possign)
            #pos is the row number in data_1 or data_2
            sign = np.sign(possign)
            #sign indicates the sign of the values 
    
            if self.dataInfo[i, 0] == 1:
                # par_or_var is a parameter
                parameters.append(par_or_var)
                parametervalues.append(self.data_1[0, pos-1] * sign)
    
            elif self.dataInfo[i, 0] == 2 or self.dataInfo[i, 0] == 0:
                # par_or_var is a variable (if == 0: time)
                variables.append(par_or_var)
            
            else:
                print par_or_var
                raise LookupError('Couldnt find this value in dataInfo')
            
        
        zipped = zip(parameters, parametervalues)
        zipped.sort()
        self.parametervalues = np.array([v for p,v in zipped]) 
        self.parameters = [p for p,v in zipped]
        self.variables = variables
        self.variables.sort()
        
        return True

    def extract(self, var, arrays='sum'):
        """Return dictionary with values of the variables/parameters to extract
        
        This method takes a dictionary as input with short_name/full_name pairs.
        It returns a dictionary with short_name/value pairs, value = numpy array.
        
        Important: value is ALWAYS a np.array, even if is it a single value
        
        Handling of arrays is implemented like this:
            - for the array variables you wish to get, replace the [i] (i=int)
              by [x].
              Example: discFullDyn20.tabs.tabs[x].nakedTabs.C2.[1].C' 
            - All values for all present 'x' will be extracted
            - argument arrays defines what happens with these values:
                - arrays='sum' (default): returns the sum of all values
                - arrays='average' returns the average of all values
                - arrays='each' : returns an array with all the values
            - Attention, the array argument defines the action for ALL arrays.
        
        If a long_name is not found, the method passes on, no exception raised!
        
        First version 20110831, RDC
        
        20111123 - raise no exception if a variable is not found
        20111128 - all values are numpy arrays. The reason for doing this is 
                   to make postprocessing more straightforward and robust
        """
        
        #pdb.set_trace()
                
        r = {}
        for short_name in var:        
            long_name = var[short_name]
            # check for array first            
            if long_name.find('[x]') > -1:
                # first, escape the \ and ] if there is an integer between them
                var_name = long_name.replace('[', '\[').replace(']', '\]').replace('\[x\]', '[x]')
                
                # alternative: with REGEX like this
                # re.sub(r'\[(\d+)\]', r'\[\1\]', var_name)   but this is slower!             
                # treat the array                
                var_name = var_name.replace('[x]', '\[[0-9]*\]')
                var_name = var_name + '$'
                # we make a list of all present array variables                    
                array_vars = self.exist(var_name)
                # we put all values in an array, as columns
                try:
                    array = self.get_value(array_vars[0])
                except(ValueError, IndexError):
                    # The array was not found: just pass to the next
                    pass
                else:
                    for v in array_vars[1:]:
                        array = np.column_stack((array, self.get_value(v)))                    
                    if arrays == 'sum':
                        r[short_name] = array.sum(axis=1)
                    elif arrays == 'mean':
                        r[short_name] = array.mean(axis=1)
                    elif arrays == 'each':
                        r[short_name] = array
                    else:
                        raise NotImplementedError('arrays='+arrays+' is an unvalid argument')    
            else: 
                # the variable is NO array
                try:
                    value = self.get_value(var[short_name])
                except ValueError:
                    # the variable is not found.  No problem, pass to the next.                    
                    pass
                else:
                    if not isinstance(value, np.ndarray):
                        r[short_name] = np.array(value, ndmin=1)
                    else:
                        r[short_name] = value
                        
        return r
        
    def get_objects(self, mother=''):
        """Get the names of the objects in a mother model
        
        Returns a list with the model names (part before the '.')
        A mother name can be specified as a string (full name up to the model).
        Example: mother = 'foo.fooBar'
        If no mother model is specified, this method gets all the main objects, 
        except 'Time'.
        
        If needed, speed can be improved by using sorted lists 
        Doesn't work with arrays yet (to do that, excape the [ and ] 
        in the mother name)
        
        First version: 20110906, RDC        
        
        """
        
        try:
            test = self.variables
        except AttributeError:
            self.separate()
        
        objects = []
        if mother == '':
            search_in = copy.copy(self.variables)
            search_in.extend(self.parameters)
            search_in.remove('Time')
            try:
                search_in.remove('stateSelect')
            except ValueError:
                pass
            index = 0
        else:
            # make the list with all variables and parameters in the mother model 
            mother_dot = mother + '.'            
            search_in = self.exist(mother_dot)
            index = mother_dot.count('.')
            
        for v in search_in:    
            potential_model = v.split('.')[index]
            try:
                objects.index(potential_model)
            except ValueError:
                objects.append(potential_model)
        try:
            objects.remove('stateSelect')
        except ValueError:
            pass
                   
        
        return objects


    def postprocess(self, process):
        """
        Return a dictionary with results as defined in process
        
        A difference is made between single line assignments (x = ...) 
        and multiline statements (if ...).  
        Therefore, the pp string can be multiline,
        and multistatements.  The distinction is made based on the second item
        after doing a pp.split(' '):
            - if it is a '=', the pp-string is an assignement and is processed 
              like that
            - else, a different syntax is applied cause the spaces in the 
              multiline expression can be of syntactic importance.  
              I still have to develop this, and the point that I didn't solve 
              yet is the attribution of the result.  If you have a string like
              if a>0:
                  b=1
              else:
                  b=2
              you have to check each line, replace a and b with their full names
              (in case of mothers) and recompose the multiline string with the 
              same spaces. Surrounding each variable name with eg '$' could be
              a good solution.  
                
        the multline thing is not implemented yet.
        
        """
        
        def convert(string):
            """
            Return a dictionary with shortname/value pairs 
            as result of a single postprocessing line string
            """

            #pdb.set_trace()
            
            returndic = {}
            splitted = string.split(' ')
            # First check if we need to loop over the mothers
            apply_on_mothers = False
            for i in splitted:
                # now we will treat each part of the string individually
                if process.sub_vars.has_key(i) or process.sub_pars.has_key(i):
                    apply_on_mothers = True
                    break
            
            # Now process the string            
            if not apply_on_mothers:
                # evaluate the string, and by passing the result dictionary 
                # as locals, the variables are known                
                returndic[splitted[0]] = eval(' '.join(splitted[2:]), globals(), result)
            else:
                # we need to find all variables and add the mothers to them
                for m in process.mothers:    
                    composed = []
                    newvar = '_'.join([m,splitted[0]]).replace('.','_')
                    for s in splitted[2:]:
                        fullname = '_'.join([m,s]).replace('.','_')
                        #print fullname
                        if result.has_key(fullname):
                            # a variable we need to get
                            composed.append(fullname)
                        else:
                            """ 
                            There are different possibilities. 
                            - it is an operation (like +, -, /, ...) ==> append to composed
                            - it is a command (like np.trapz(var) ==> not yet implmented
                            - it is a variable that does not occur in this simulation:
                                appending it to composed will lead to a name error
                                because it is not present in the result dict.  
                                For now, we just catch the error and print a warning
                            """                            
                            composed.append(s)
                    #print 'composed string: ', newvar, ' = ', ' '.join(composed)
                    try:
                        returndic[newvar] = eval(' '.join(composed), globals(), result)
                    except(NameError) as e:
                        print 'This pp string could not be evaluated:'
                        print newvar, ' = ', ' '.join(composed)
                        print 'Error message =  %s' % e
                    except:
                        print 'Error during this evaluation:'
                        print newvar, ' = ', ' '.join(composed)
                        raise
                 
                # To ensure that the newly created var can be used later on:
                process.sub_vars[splitted[0]] = splitted[0]

            return returndic
            
        def make_datetimeindex(array_in_seconds, year):
            """
            Create a pandas DateIndex from a time vector in seconds and the year.
            """
            
            start = pandas.datetime(year, 1, 1)
            datetimes = [start + pandas.datetools.timedelta(t/86400.) for t in array_in_seconds]
            
            return pandas.DatetimeIndex(datetimes)
        
        
        def aggregate_by_time(signal, period=86400, interval=900, label='left'):
            """
            Function to calculate the aggregated average of a timeseries by 
            period (typical a day) in bins of interval seconds (default = 900s).
            
            label = 'left' or 'right'.  'Left' means that the label i contains data from 
            i till i+1, 'right' means that label i contains data from i-1 till i.    
            
            Returns an array with period/interval values, one for each interval
            of the period. 
            
            A few limitations of the method:
                - the period has to be a multiple of the interval
                - periods larger than 1 day are not supported yet
            
            This function can be used in the post-processing
            """
            
            
            #pdb.set_trace()
            interval_string = str(interval) + 'S'    
            df = pandas.DataFrame(data=signal, index=dt_index, columns=['signal'])
            try:
                df15min = df.resample(interval_string, closed=label, label=label)
            except:
                print "\nThis exception could be the result of a resampling to \
                a higher frequency than the timestep of the results\n"
                raise
            
            # now create bins for the groupby() method
            time_s = df15min.index.asi8/1e9
            time_s -= time_s[0]
            df15min['bins'] = np.mod(time_s, period)
            
            df_aggr = df15min.groupby(['bins']).mean()
            
            return df_aggr.values   


        
        vars_and_pars = {}
        vars_and_pars.update(process.variables)
        vars_and_pars.update(process.parameters)
        result = self.extract(vars_and_pars, arrays='each')
        # pass the function aggregate_by_time to the dictionary 
        # in order to get it in the namespace + create the datetimeindex
        result['aggregate_by_time'] = aggregate_by_time
        global dt_index
        dt_index = make_datetimeindex(result['Time'], 2010)
        
        if process.mothers not in (None, []):
            result['mothers'] = process.mothers
        
        if process.pp is not None:
            for p in process.pp:
                if self.verbose:
                    print p
                d = convert(p)
                result.update(d)
        
        result.pop('aggregate_by_time') 
        return result
        
    def analyse_cputime(self, variables=None, interval=900, screendump=30):
        """Analyse the relation between cputime and some variables.
    
        It is required that the time array of the simulation contains an 
        entry for every multiple of the interval.
    
        Parameters:
        -----------
        * variables: dictionary with name/array for which the correlation 
          is to be found.  If the variablename ends with Int (case sensitive)
          it is supposed to be cumulative
          if variables = None, all variables found in the simulation are tested.
        * interval: the desired interval for resampling, integer in seconds
        * screendump: integer, number of lines to print.  A negative number
          prints all the results
        
    
        Output:
        -------
        dictionary with same keys as variables, and the correlation as values
        """
        
        res = {}        
        
        #pdb.set_trace()
        time = self.get_value('Time')
        try:
            cputime = self.get_value('CPUtime')
        except(ValueError):
            raise ValueError("This simulation has no trajectory for CPUtime")
        
        x = np.arange(time[0], time[-1], interval)
        index = np.searchsorted(time, x)
        try:
            cpu_smpl = cputime[index]
        except(IndexError):
            print "====================== ERROR ====================="
            print "This IndexError can be caused by a wrong interval."
            print "Your interval setting was %s seconds" % (interval)
            print "Make sure the simulation has this output interval"
            raise
            
        cpu_diff = np.diff(cpu_smpl)
        
        if variables is None:
            self.separate()
            variables = self.extract({v:v for v in self.variables})
        
        for varname, array in variables.items():        
            if varname.endswith('Int') or varname == 'CPUtime':
                # we suppose the array is cumulative
                var_cum = array
            else:
                var_cum = cumtrapz(array, time)
                
            try:
                var_smpl = var_cum[index]
            except(IndexError):
                print "====================== ERROR ====================="
                print "This IndexError can be caused by a wrong interval."
                print "Your interval setting was %s seconds." % (interval)
                print "Make sure the simulation has this output interval."
                raise
            
            var_diff = np.diff(var_smpl)
            
            res[varname] = np.min(np.corrcoef(var_diff, cpu_diff))
            
        good_results = {k:v for k,v in res.items() if not np.isnan(v)}
            
        keys_sorted = sorted(good_results.items(), key=lambda x: np.abs(x[1]), reverse=True)
        if screendump < 0:
            nlines = len(keys_sorted)
        else:
            nlines = screendump
        
        if nlines > 0:
            print 'The highest correlations were found for :'
            for k,v in keys_sorted[:nlines]:
                print '\t', k, '.'*(50-len(k)), ' ==> ', '%.2f' % (v)
            
            #print 'The lowest correlations were found for :'
            #for k,v in keys_sorted[:10]:
            #    print '\t', k, ' '*(40-len(k)), ' ==> ', '%.2f' % (v)
 

        return res